[![Stories in Ready](https://badge.waffle.io/Praqma/Praqmatic-Automated-Changelog.png?label=Status%20-%20-workable&title=Workable)](https://waffle.io/Praqma/Praqmatic-Automated-Changelog)
# Praqmatic Automated Changelog (PAC)

Tool for creating automated, but pragmatic, changelogs.

Compared to other ways of extracting changes, typically from the SCM commit messages, this is based around getting information from another source by looking up references to such in the SCM commit message.

Currently proof-of-concepts handles

* git dvcs
* hg dvcs

You can output in any format you like using the liquid templating language. We have the option to turn html into pdf with the pdf switch in the template setup.

## Settings file example (Jira)

Below is an example of an example that uses Jira.

	:general:
	  date_template: '%Y-%m-%d'

	:templates:
	  - { location: templates/default_id_report.md, output: ids.md }
	  - { location: templates/default.md, output: default.md }
	  - { location: templates/default_html.html, pdf: true, output: default.html }

	:task_systems:
	  - 
	    :name: none
	    :regex:
	      - { pattern: '/Issue:\s*(\d+)/i', label: none }
	      - { pattern: '/Issue:\s*(none)/i', label: none }
	      - { pattern: '/(#\d+)/', label: none }
	      - { pattern: '/us:(\d+)/', label: none }
	    :delimiter: '/,|\s/'
	  -
	    :name: jira
	    :query_string: "http//your.server.hostname/jira/rest/api/latest/#{task_id}"
	    :usr: "user"  
	    :pw: "password"
	    :regex:
	    - { pattern: '/PRJ-(\d+)/i', label: jira }      
	  -
	    :name: trac
	    :trac_url: "https://my.trac.site"
	    :trac_usr: "user"
	    :trac_pwd: "pass"
	    :regex:
	    - { pattern: '/Ticket-(\d+)/i', label: trac }  	   

## Noteworthy information

The settings file has the list of regular expression, each pattern has one `label` property. When a regular expression is matched, the label from the matched commit is applied to the task the commit belongs to. Each task can contain multiple labels, a good example would be to scan for commits with a task reference that has the words "Wont fix" and apply the label `wont_fix` to those matched commits.

Notice the `pdf: true` attribute on the template. PAC has the ability to transform the html output generated by the template to a .pdf file. This requires special configuration for the docker machine and is generally not recommended, we've seen issues with unicode characters. 


### Jira specific information

The query string do not handle redirects, so you must prepend the correct protocol in your `query_string` setting. The behavior of PAC changes if you have specified `https` or `http` always specify the full url, including the correct protocol to use.

## The templating engine

PAC now comes with a templating engine. We have a set of standard variables which can be used in the template. The location of the templates and their outputs can be configured by modifying the `:templates:` section of the settings file.

Below is an example of the standard markdown template

	# {{title}}
	{% for task in tasks.referenced %}
	## {{task.task_id}}
	{% for commit in task.commits %}
	- {{commit.shortsha}}: {{commit.header}}
	{% endfor %}
	{% endfor %}
	## Unspecified
	{% for commit in tasks.unreferenced %}
	- {{commit.shortsha}}: {{commit.header}} 
	{% endfor %}

	## Nones
	{% for task in tasks.none %}
	- {{task.task_id}}
	{% endfor %}

	## Statistics
	- Total numerber of commits: {{pac_c_count}}
	- Referenced commits: {{pac_c_referenced}}
	- Health: {{pac_health}}

We expose the following attributes

* `title` The title of the report
* `tasks.referenced` All tasks which have been matched 
* `tasks.[label]` All tasks with the assigned label. In the example above case all tasks with label 'none' will be iterated
* `tasks.task.[commits | task_id]` A task has a list of commits. And an id.
* `tasks.unreferenced` The list of commits that has NOT been referenced with a task
* `commit.[header | shortsha]` A Commit has a header (The text until the first linebreak) and a SHA
* `pac_c_count` Number of commits in total
* `pac_c_referenced` Number of referenced commits
* `pac_health` The 'health' of the changelog. Returns the percentage of referenced commits 

PAC comes with a set of default templates. Take a look at those for inspiration. The templating system allows you to build a simple .txt file if that is your wish.

### Jira template extras

Several fields are added when a task is matched for a jira issue if you have a configured issue link like so: `https://your.first.server.com/rest/api/latest/issue/#{task_id}?fields=issuetype` you get a json response that looks something like this:

	{
		"expand":"renderedFields,names,schema,transitions,operations,editmeta,changelog,versionedRepresentations",
		"id":"10000",
		"self":"https://your.first.server.com/rest/api/latest/issue/10000",
		"key":"PP-1",
		"fields":{
			"issuetype": {
				"self":"https://your.first.server.com/rest/api/2/issuetype/10001",
				"id":"10001",
				"description":"gh.issue.story.desc",
				"iconUrl":"https://your.first.server.com/images/icons/issuetypes/story.svg",
				"name":"Story",
				"subtask":false
			}
		}
	}

The fields are then accessed like so:

* `task.attributes.data.id` The id value of the json above
* `task.attributes.data.fields.issuetype.[self | id | description | iconUrl | name | subtask]` All values under issuetype

Basically you can 'dot' your way through the values and include the values you want from jira. What data you have available depends on your query string 
in the configuration file.  

## Testing your regex with the IRB

When you construct your regexp, the IRB is helpful. To start out with you can comment out all task systems except for the `none` system to verify that
you capture the correct task id's. Use the interactive ruby interpreter to test your regular expressions.

Example one, checking the above example regexp works as we expect

	2.2.1 :001 > commit_message ="Commit message header
	2.2.1 :002"> 
	2.2.1 :003"> More lines in commit message
	2.2.1 :004"> Issue: 12"
	 => "Commit message header\n\nMore lines in commit message\nIssue: 12"
 	2.2.1 :015 > regex = /Issue:\s+(\d+)/im
 	=> /Issue:\s+(\d+)/mi 
	2.2.1 :016 > commit_message.scan(regex)
 	=> [["12"]] 

The script uses the scan method to scan the commit mesage, so for each result the script looks in the first capture group, in this case
PAC would have picked up an issue with the id "12". The scan method can return multiple matches on the same text so make sure your capture first capture group
contains the id you want.

## Usage examples

_Note there is a docker container available also, which makes the tools and environment setup easier: [Praqma/docker-pac](https://github.com/Praqma/docker-pac)_

Show help

    ./pac.rb -h
    
Get commits using tags. tail tag provided

    ./pac.rb -t Release-1.0 --settings=./pacfogbugz_pac_settings.yml

Get commits using tags, head and tail tags provided

    ./pac.rb -t Release-1.0 Release-2.0 --settings=./pacfogbugz_pac_settings.yml

Get commits using time

    ./pac.rb -d 2013-10-01 --settings=./pacfogbugz_pac_settings.yml 
    
Get all commits since latest point release. Given a specified pattern. Default is 'tags'

	./pac.rb -t LATEST --settings=./pacfogbugz_pac_settings.yml --pattern='tags/Release-1.*'

Note that when using tags with a pattern that matches multiple tags, the latest is always used. The comparison is always compared to HEAD.

## Using the Praqma/docker-pac container

The docker container for PAC works by mounting a git repository into the container as a volume, by default the folder `/work` is set as the current 
working directory inside the container.

So in order to test, and try out the container do the following:

* Unzip the file `test/resources/idReportTestRepository.zip` file from this repository to a folder on your computer
* Create a file `default_settings.yml` and paste the contents from below into this file. Put the file in the root of the extracted Git repository 

```
:general:
  date_template: "%Y-%m-%d"
  :strict: true

:templates:
  - { location: /usr/src/app/templates/default_id_report.md, output: ids.md }
  - { location: /usr/src/app/templates/default.md, output: default.md }
  - { location: /usr/src/app/templates/default_html.html, pdf: true, output: default.html }

:task_systems:
  - 
    :name: none
    :regex:
      - { pattern: '/.*Issue:\s*(?<id>[\d+|[,|\s]]+).*?\n/im', label: none }
      - { pattern: '/.*Issue:\s*?(none).*?\n/im', label: none}
    :delimiter: '/,|\s/'
  
:vcs:
  :type: git
  :usr:
  :pwd:
  :repo_location: '.'
  :release_regex: 'tags'
```

Now, when this is done, you should be able to run PAC, the example below is where we extracted the idTestRepository to my home folder:

`docker run --rm -v /home/mads/idReportTestRepository:/data praqma/pac -s f9a66ca6d2e6`

If PAC is working, you should see the following on system out:

	[PAC] Applying task system none

and if you do an `ls -al` in your repostitory it should now look like this:

	-rwxrwxrwx 1 mads mads   759 Apr 12 10:24 default.html
	-rwxrwxrwx 1 mads mads   356 Apr 12 10:24 default.md
	-rwxrwxrwx 1 mads mads 21047 Apr 12 10:24 default.pdf
	-rw-rw-r-- 1 mads mads   608 Apr 12 10:23 default_settings.yml
	drwxrwxr-x 8 mads mads  4096 Apr 27  2015 .git
	-rwxrwxrwx 1 mads mads   489 Apr 12 10:24 ids.md
	-rw-rw-r-- 1 mads mads   340 Apr 27  2015 README.md

That's it. You've now succesfully created a changelog, automagically.

## Prerequisites
If you are going to be using the tool to generate PDF files which we use kramdown and pdfkit to generate you'll need to run the following command and a linux machine

`sudo apt-get install libxslt-dev libxml2-dev`

`sudo apt-get install wkhtmltopdf`

Also you'll need to install the gems specified in the Gemfile in order to get it working. At the current state Linux support is much better than windows

_Note there is a docker container available also, which makes the tools and environment setup easier: [Praqma/docker-pac](https://github.com/Praqma/docker-pac)_

## Developer info

### Program flow

The general program can be described this way

1. The Vcs module obtains a list of commits object from [Rugged](https://github.com/libgit2/rugged), given user supplied repository and start/finish. 
2. The Vcs turns the [Rugged](https://github.com/libgit2/rugged) commits into PACCommit model objects and returns an array of these in the `PACCommitCollection`. The commit collection functions just like a regular list in Ruby, you can add stuff to it with the `add` method etc. Refer to the source code for information. 
3. The Core module then produces a bare bones `PACTaskCollection` with tasks, the tasks only has the id property.
4. After the bare `PACTaskCollection` has been generated, each task system applies it's decorator(s) to the task adding additonal data.
5. The `PACTaskCollection` is then passed to the Liquid template engine and the outputs are produced

Since [Liquid](https://shopify.github.io/liquid/) has a very strict object model, and no ruby code is allowed inside templates (you can use simple filters and chain theme together with th | (pipe), we need to transform the data in `PACTaskCollection` so that Liquid understands it. For example, symbols as has keys are not allowed in the template.

You are also required to bind Model objects to Liquid locals to be used in templates see the `Notes on Liquid` section.

### Object model 

The principal model in PAC consists of the following ruby `Modules` 
* Core
* Vcs
  * GitVcs
  * MercurialVcs
* Model
  * PACTask
  * PACTaskCollection
  * PACCommit
  * PACCommitCollection
* Report
  * Generator
* Task
  * JiraTaskSystem
  * TracTaskSystem

*Module: Core*

The responsibility of `Core` is to combine the data found in the `Vcs` module and using this information together with the information from the `Task` module
to produce a gross list of tasks discovered. 

The `Core` module is used in the _Main_ method of the pac.rb script.   

*Module: Vcs*

The `Vcs` module handles the interaction with the chosen VCS (Usually Git). Given a set of parameters it will return a list of commits in the form of `PACCommitCollection` model object.

*Module: Model*

The `Model` module contains all the object models needed. We have the folling, the names make it clear what their responsibilities are
* PACCommit
* PACCommitCollection
* PACTask
* PACTaskCollection

`PACCommit` is just a data structure that encapsulates the `Rugged` commit. It has the `referenced` member which is an indication wheather or not this commit had a task reference.

```
class PACCommit
  def initialize(sha, message = nil, date = nil)
	@sha = sha
	@message = message
	@referenced = false
	@date = date
  end
end
``` 

The `PACTaskCollection` has a method to add _n_ tasks to the list. If the task was already added, based on the unique id, then the commits of the two tasks are 
merged, resulting in 1 task, with the extra commits from the other tasks. This happens if a task is referenced in multiple commits. The _uniqueness_ is implemented in the `PACTaskCollection`. The `PACTaskCollection` basically encapsulates a Ruby list, with some additional logic to ensure uniqueness.

```
class PACTaskCollection
  def initialize
    @tasks = []
  end
end 
```

In order to ensure uniqueness, the _==_ (equals) method on the `PACTask` has been overridden, to only take into account the id of the task when determining equality.

The `PACTask` object has a collection of associated commits. It also holds references to the names of which task systems the task applies to. Also labels tied to the commit are also applied to the task, so that the tasks can be sorted by their labels. A `PACTask` can contain multiple labels. 

```
class PACTask
  def initialize(task_id = nil)
    @task_id = task_id      
    @commit_collection = PACCommitCollection.new 
    @attributes = { }
    @applies_to = Set.new      
    @label = Set.new
  end
end
```

*Module: Report*

The `Report` module has one class. The generator class that produces the output files. This generator needs to know a complete lists of tasks, the commits involved and a list of user defined templates to generate the report from. Currently we only have Jekyll generation capabilities.  

*Module: Task*

The `Task` module is responsible for applying the appropriate decorators for the task system. It is entirely possible to apply more than one decorator.
The module expects a list of tasks, the id of each task is used to query the task system and add additional info to the task.


### Notes on Liquid

In order for liquid to produce locals for the template, we implemented a `to_liquid` method. This method should return a hash whose keys can be used 
as parameters in the template.

Here is an example

    def to_liquid
      { 
        'task_id' => @task_id, 
        'commits' => @commit_collection, 
        'attributes' => attributes,
        'label' => label
      }
    end


### Tests

Tests can be easily executed by running `rake test` for unit tests and `rake functional_test` for functional tests.

#### Integration tests for supported tasks systems

 * spin up a container with the task system
 * configure it
 * poor known test data into the system
 * run all relevant tests on the systems (assuming they do not change data)
 * shut down and clean-up containers

Possibly container, configuration and test data could be combined into a new container to save spin-up time. 

Note also that tests relies on know test data, e.g. task references etc. thus they are off-course part of this repository.

Choice of containers:

* **Jira**: The [`blacklabelops/jira`](https://hub.docker.com/r/blacklabelops/jira/) container seems very popular and easy to use, thus this is chosen as base container for Jira. . Compared to our own (Praqma) [staci project](https://github.com/Praqma/staci) that start a complete Atlassian suite, this simple jira container seems easier to start with.
* **Trac**: 

#### TEMP NOTES

* License nees to be `JIRA Software (server)` so we get the projectype software in Jira 7.x that fits the autogenerated test data from http://jumble.expium.com/
* Seem like we can re-use the same license key for new servers, even though Server ID changes.
* Project types: https://confluence.atlassian.com/adminjiraserver070/jira-applications-and-project-types-overview-776637041.html


#### Start jira test instance:


* ./test/resources/start_task_system.sh jira 9090
* **Manual step - adding license and import test data 
    * open http://localhost:9090 (use the same port as in earlier command)
    * Click `Next` in the `Set up application properties` - keeping default choices
    * Insert license key from `test/resources/jira-software-server-license.txt`, click next
    * Configure admin account with input fields respectively: admin, support@praqma.net, admin, admin, admin (which gives `admin`- account with pass `admin`)
    * click Finish
    * skip quick tour
* **Manual step**: import our test data...
    * Jira Administration -> System -> External System Import -> JSON and chose file `test/resources/0578a7b0-fd81-11e5-a150-91d01466654e.json`
    * leave users in-active
    * perform re-index


## Installation on windows

To run it on windows you need to install ruby installer x86 and devkit x86 [link](http://rubyinstaller.org/downloads/)

To install ruby devkit follow these [instructions](https://github.com/oneclick/rubyinstaller/wiki/Development-Kit)

Rugged requires CMake and pkg-config. 

CMake can be downloaded from [here](http://www.cmake.org/files/v3.2/cmake-3.2.3-win32-x86.zip)

pkg-config has some dependencies. However, there's a [nice package bundled with the dependencies](http://iweb.dl.sourceforge.net/project/mingw-w64/Toolchains%20targetting%20Win64/Personal%20Builds/ray_linn/64bit-libraries/pkg-config/pkg-config-0.26.7z).

Start by installing bundler with this command `gem install bundler`. Followed by a `bundle` command inside the project root directory. 

## Contributors
* Hugo Leote (hleote@praqma.net)
* Martin Georgiev (mvgeorgiev@praqma.net)
* Mads Nielsen (man@praqma.net)
* Bue Petersen (bue@praqma.net)
* Andrius Ordojan (and@praqma.net)

